---
title: Create apps
weight: 4
description: |
  Control your apps and how they're built and deployed on Platform.sh with YAML configuration.
aliases:
  - "/configuration/app-containers.html"
layout: single
---

{{< description >}}

![Applications](/images/config-diagrams/applications.png "0.50")

Within a single project, you can have one or more app and each app can have multiple instances.
All of the apps and instances are configured with the same syntax.
You can find a [complete reference](./app-reference.md) of all possible settings.

## Basic setup

To create a very basic app, you need a few things:

* A unique `name` not shared by any other app in the project.
* The runtime `type` defining what language it uses.
* A `disk` size for your deployed files.
* A definition of how to handle requests from the outside `web`.

The following example shows such a basic setup for PHP:

```yaml
# The name of this application, which must be unique within the project.
name: 'app'

# The language and version for your app.
type: 'php:8.0'

# The size of the app's persistent disk (in MB).
disk: 2048

# The app's configuration when it's exposed to the web.
web:
    locations:
        '/':
            # The public directory relative to the app root.
            root: 'web'
            # The front-controller script which determines where to send non-static requests.
            passthru: '/app.php'
```

## Use multiple apps

You might have multiple apps you want to run from a single Git repository,
such as a RESTful web service and a front-end or a main website and a blog.
In such cases, you need to set configuration separately for each app.
See the various ways to set up a [multi-app project](./multi-app.md).

## Connect to services

If you want to use one of the [services Platform.sh provides](../services/_index.md), you need to set up that connection.
First, configure the service based on the documentation for that service.
Then use the information from that service inside your app's [`relationships` definition](./app-reference.md#relationships)
to configure how your app communicates with the service.

## Control the build process

Your app generally needs to undergo some steps to be turned from a Git repository into a running app.
If you're running a PHP or Node.js app, this starts with the [build flavor](./app-reference.md#build),
which runs a default set of tasks.
Then any [global dependencies](./app-reference.md#dependencies) can be installed.

Once these optional tasks are done, you can run [hooks](./hooks.md) at various points in the process.
These are places for your custom scripts to control how your app is built.

## Configure what's served

Once your app is built, it needs a defined way to communicate with the outside world.
Define its behavior with a [`web` instance](./app-reference.md#web).
There you can set what command runs every time your app is restarted,
how dynamic requests are handled, and how to respond with static files.

## Compression

Dynamic responses generated by your app aren't compressed because of a [general security issue](https://en.wikipedia.org/wiki/BREACH_%28security_exploit%29).
While your application can compress its own response,
doing so when the response includes any user-specific information, including a session cookie,
opens up an attack vector over SSL/TLS connections.
For that reason, you generally shouldn't compress generated responses.

Requests for static files that are served directly by Platform.sh are compressed automatically
using either gzip or Brotli compression if:

* The request headers for the file support gzip or Brotli compression.
* The file is served directly from disk by Platform.sh and not passed through your application.
* The file would be served with a cache expiration time in the future.
* The file type is one of: HTML, JavaScript, JSON, PDF, PostScript, SVG, CSS, CSV, plain text, or XML.

Also, if there is a request for a file and another file exists with the same name plus a `.gz` or `.br` extension,
the compressed file is served regardless of the original file type.
So a request for `styles.css` that accepts a gzipped file (according to the request headers)
automatically returns a `styles.css.gz` file if it exists.
This approach supports any file type and offers some CPU optimization, especially if the cache lifetime is short.
